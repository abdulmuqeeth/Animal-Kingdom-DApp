{"ast":null,"code":"/*\n * This code is taken from https://github.com/Brightspace/node-ecdsa-sig-formatter\n * which is licensed under the Apache 2.0 license.\n *\n * It got copied over here to make some adjustments for being compatible with browserify.\n * Going forward would be either simplifying this code (as we only need 256 bit signatures),\n * or moving back to the direct dependency; both is future work(TM) for some other day.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.derToJose = derToJose;\nexports.joseToDer = joseToDer;\n\nvar asn1 = require('asn1.js');\n\nfunction base64UrlEscape(str) {\n  return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nvar ECDSASigValue = asn1.define('ECDSASigValue', function () {\n  this.seq().obj(this.key('r').int(), this.key('s').int());\n});\nvar seq = 0x10,\n    int = 0x02;\n\nfunction getParamSize(keySize) {\n  var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n  return result;\n}\n\nvar paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(512)\n};\n\nfunction getParamBytesForAlg(alg) {\n  var paramBytes = paramBytesForAlg[alg];\n\n  if (paramBytes) {\n    return paramBytes;\n  }\n\n  throw new Error('Unknown algorithm \"' + alg + '\"');\n}\n\nfunction bignumToBuf(bn, numBytes) {\n  var buf = Buffer.from(bn.toString('hex', numBytes), 'hex');\n  return buf;\n}\n\nfunction signatureAsBuffer(signature) {\n  if (Buffer.isBuffer(signature)) {\n    return Buffer.from(signature);\n  } else if ('string' === typeof signature) {\n    return Buffer.from(signature, 'base64');\n  }\n\n  throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction reduceBuffer(buf) {\n  var padding = 0;\n\n  for (var n = buf.length; padding < n && buf[padding] === 0;) {\n    ++padding;\n  }\n\n  var needsSign = buf[padding] >= 0x80;\n\n  if (needsSign) {\n    --padding;\n\n    if (padding < 0) {\n      var old = buf;\n      buf = Buffer.alloc(1 + buf.length);\n      buf[0] = 0;\n      old.copy(buf, 1);\n      return buf;\n    }\n  }\n\n  if (padding === 0) {\n    return buf;\n  }\n\n  buf = buf.slice(padding);\n  return buf;\n}\n\nfunction derToJose(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  signature = ECDSASigValue.decode(signature, 'der');\n  var r = bignumToBuf(signature.r, paramBytes);\n  var s = bignumToBuf(signature.s, paramBytes);\n  signature = Buffer.concat([r, s], r.length + s.length);\n  signature = signature.toString('base64');\n  signature = base64UrlEscape(signature);\n  return signature;\n}\n\nfunction joseToDer(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  var signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n  }\n\n  var r = reduceBuffer(signature.slice(0, paramBytes));\n  var s = reduceBuffer(signature.slice(paramBytes));\n  var rsBytes = 1 + 1 + r.length + 1 + 1 + s.length;\n  var oneByteLength = rsBytes < 0x80;\n  signature = Buffer.alloc((oneByteLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  signature[offset++] = seq | 0x20 | 0 << 6;\n\n  if (oneByteLength) {\n    signature[offset++] = rsBytes;\n  } else {\n    signature[offset++] = 0x80 | 1;\n    signature[offset++] = rsBytes & 0xff;\n  }\n\n  signature[offset++] = int | 0 << 6;\n  signature[offset++] = r.length;\n  r.copy(signature, offset);\n  offset += r.length;\n  signature[offset++] = int | 0 << 6;\n  signature[offset++] = s.length;\n  s.copy(signature, offset);\n  return signature;\n}","map":null,"metadata":{},"sourceType":"script"}