{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nvar _base64url = require('base64url');\n\nvar _base64url2 = _interopRequireDefault(_base64url);\n\nvar _cryptoClients = require('./cryptoClients');\n\nvar _errors = require('./errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction createSigningInput(payload, header) {\n  var tokenParts = []; // add in the header\n\n  var encodedHeader = _base64url2.default.encode(JSON.stringify(header));\n\n  tokenParts.push(encodedHeader); // add in the payload\n\n  var encodedPayload = _base64url2.default.encode(JSON.stringify(payload));\n\n  tokenParts.push(encodedPayload); // prepare the message\n\n  var signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  var header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nvar TokenSigner = function () {\n  function TokenSigner(signingAlgorithm, rawPrivateKey) {\n    _classCallCheck(this, TokenSigner);\n\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new _errors.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = _cryptoClients.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  _createClass(TokenSigner, [{\n    key: 'header',\n    value: function header() {\n      var _header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var defaultHeader = {\n        typ: this.tokenType,\n        alg: this.cryptoClient.algorithmName\n      };\n      return Object.assign({}, defaultHeader, _header);\n    }\n  }, {\n    key: 'sign',\n    value: function sign(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // generate the token header\n\n      var header = this.header(customHeader); // prepare the message to be signed\n\n      var signingInput = createSigningInput(payload, header);\n      var signingInputHash = this.cryptoClient.createHash(signingInput); // sign the message and add in the signature\n\n      var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n      if (expanded) {\n        return {\n          'header': [_base64url2.default.encode(JSON.stringify(header))],\n          'payload': JSON.stringify(payload),\n          'signature': [signature]\n        };\n      } else {\n        return [signingInput, signature].join('.');\n      }\n    }\n  }]);\n\n  return TokenSigner;\n}();\n\nexports.TokenSigner = TokenSigner;","map":null,"metadata":{},"sourceType":"script"}