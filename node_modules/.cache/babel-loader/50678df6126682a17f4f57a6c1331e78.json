{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SECP256K1Client = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _elliptic = require('elliptic');\n\nvar _crypto = require('crypto');\n\nvar _keyEncoder = require('key-encoder');\n\nvar _keyEncoder2 = _interopRequireDefault(_keyEncoder);\n\nvar _validator = require('validator');\n\nvar _ecdsaSigFormatter = require('./ecdsaSigFormatter');\n\nvar _errors = require('../errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SECP256K1Client = exports.SECP256K1Client = function () {\n  function SECP256K1Client() {\n    _classCallCheck(this, SECP256K1Client);\n  }\n\n  _createClass(SECP256K1Client, null, [{\n    key: 'createHash',\n    value: function createHash(signingInput) {\n      return (0, _crypto.createHash)('sha256').update(signingInput).digest();\n    }\n  }, {\n    key: 'loadPrivateKey',\n    value: function loadPrivateKey(rawPrivateKey) {\n      if (rawPrivateKey.length === 66) {\n        rawPrivateKey = rawPrivateKey.slice(0, 64);\n      }\n\n      return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n  }, {\n    key: 'loadPublicKey',\n    value: function loadPublicKey(rawPublicKey) {\n      return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n  }, {\n    key: 'encodePublicKey',\n    value: function encodePublicKey(publicKey, originalFormat, destinationFormat) {\n      return SECP256K1Client.keyEncoder.encodePublic(publicKey, originalFormat, destinationFormat);\n    }\n  }, {\n    key: 'derivePublicKey',\n    value: function derivePublicKey(privateKey, compressed) {\n      if (typeof privateKey !== 'string') {\n        throw Error('private key must be a string');\n      }\n\n      if (!(0, _validator.isHexadecimal)(privateKey)) {\n        throw Error('private key must be a hex string');\n      }\n\n      if (privateKey.length == 66) {\n        privateKey = privateKey.slice(0, 64);\n      } else if (privateKey.length <= 64) {// do nothing\n      } else {\n        throw Error('private key must be 66 characters or less');\n      }\n\n      if (compressed === undefined) {\n        compressed = true;\n      }\n\n      var keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n      return keypair.getPublic(compressed, 'hex');\n    }\n  }, {\n    key: 'signHash',\n    value: function signHash(signingInputHash, rawPrivateKey) {\n      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose'; // make sure the required parameters are provided\n\n      if (!(signingInputHash && rawPrivateKey)) {\n        throw new _errors.MissingParametersError('a signing input hash and private key are all required');\n      } // prepare the private key\n\n\n      var privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey); // calculate the signature\n\n      var signatureObject = privateKeyObject.sign(signingInputHash);\n      var derSignature = Buffer.from(signatureObject.toDER());\n\n      if (format === 'der') {\n        return derSignature.toString('hex');\n      } else if (format === 'jose') {\n        // return the JOSE-formatted signature\n        return (0, _ecdsaSigFormatter.derToJose)(derSignature, 'ES256');\n      } else {\n        throw Error('Invalid signature format');\n      }\n    }\n  }, {\n    key: 'loadSignature',\n    value: function loadSignature(joseSignature) {\n      // create and return the DER-formatted signature buffer\n      return (0, _ecdsaSigFormatter.joseToDer)(joseSignature, 'ES256');\n    }\n  }, {\n    key: 'verifyHash',\n    value: function verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n      // make sure the required parameters are provided\n      if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n        throw new _errors.MissingParametersError('a signing input hash, der signature, and public key are all required');\n      } // prepare the public key\n\n\n      var publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey); // verify the token\n\n      return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n  }]);\n\n  return SECP256K1Client;\n}();\n\nSECP256K1Client.algorithmName = 'ES256K';\nSECP256K1Client.ec = new _elliptic.ec('secp256k1');\nSECP256K1Client.keyEncoder = new _keyEncoder2.default({\n  curveParameters: [1, 3, 132, 0, 10],\n  privatePEMOptions: {\n    label: 'EC PRIVATE KEY'\n  },\n  publicPEMOptions: {\n    label: 'PUBLIC KEY'\n  },\n  curve: SECP256K1Client.ec\n});","map":null,"metadata":{},"sourceType":"script"}