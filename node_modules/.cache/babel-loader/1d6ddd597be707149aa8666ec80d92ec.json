{"ast":null,"code":"'use strict';\n\nvar asn1 = require('asn1.js'),\n    BN = require('bn.js'),\n    EC = require('elliptic').ec;\n\nvar ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').explicit(0).objid().optional(), this.key('publicKey').explicit(1).bitstr().optional());\n});\nvar SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(this.key('algorithm').seq().obj(this.key(\"id\").objid(), this.key(\"curve\").objid()), this.key('pub').bitstr());\n});\nvar curves = {\n  secp256k1: {\n    curveParameters: [1, 3, 132, 0, 10],\n    privatePEMOptions: {\n      label: 'EC PRIVATE KEY'\n    },\n    publicPEMOptions: {\n      label: 'PUBLIC KEY'\n    },\n    curve: new EC('secp256k1')\n  }\n};\n\nfunction assert(val, msg) {\n  if (!val) {\n    throw new Error(msg || 'Assertion failed');\n  }\n}\n\nfunction KeyEncoder(options) {\n  if (typeof options === 'string') {\n    assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);\n    options = curves[options];\n  }\n\n  this.options = options;\n  this.algorithmID = [1, 2, 840, 10045, 2, 1];\n}\n\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;\n\nKeyEncoder.prototype.privateKeyObject = function (rawPrivateKey, rawPublicKey) {\n  var privateKeyObject = {\n    version: new BN(1),\n    privateKey: new Buffer(rawPrivateKey, 'hex'),\n    parameters: this.options.curveParameters\n  };\n\n  if (rawPublicKey) {\n    privateKeyObject.publicKey = {\n      unused: 0,\n      data: new Buffer(rawPublicKey, 'hex')\n    };\n  }\n\n  return privateKeyObject;\n};\n\nKeyEncoder.prototype.publicKeyObject = function (rawPublicKey) {\n  return {\n    algorithm: {\n      id: this.algorithmID,\n      curve: this.options.curveParameters\n    },\n    pub: {\n      unused: 0,\n      data: new Buffer(rawPublicKey, 'hex')\n    }\n  };\n};\n\nKeyEncoder.prototype.encodePrivate = function (privateKey, originalFormat, destinationFormat) {\n  var privateKeyObject;\n  /* Parse the incoming private key and convert it to a private key object */\n\n  if (originalFormat === 'raw') {\n    if (!typeof privateKey === 'string') {\n      throw 'private key must be a string';\n    }\n\n    var privateKeyObject = this.options.curve.keyFromPrivate(privateKey, 'hex'),\n        rawPublicKey = privateKeyObject.getPublic('hex');\n    privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n  } else if (originalFormat === 'der') {\n    if (typeof privateKey === 'buffer') {// do nothing\n    } else if (typeof privateKey === 'string') {\n      privateKey = new Buffer(privateKey, 'hex');\n    } else {\n      throw 'private key must be a buffer or a string';\n    }\n\n    privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n  } else if (originalFormat === 'pem') {\n    if (!typeof privateKey === 'string') {\n      throw 'private key must be a string';\n    }\n\n    privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n  } else {\n    throw 'invalid private key format';\n  }\n  /* Export the private key object to the desired format */\n\n\n  if (destinationFormat === 'raw') {\n    return privateKeyObject.privateKey.toString('hex');\n  } else if (destinationFormat === 'der') {\n    return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n  } else if (destinationFormat === 'pem') {\n    return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n  } else {\n    throw 'invalid destination format for private key';\n  }\n};\n\nKeyEncoder.prototype.encodePublic = function (publicKey, originalFormat, destinationFormat) {\n  var publicKeyObject;\n  /* Parse the incoming public key and convert it to a public key object */\n\n  if (originalFormat === 'raw') {\n    if (!typeof publicKey === 'string') {\n      throw 'public key must be a string';\n    }\n\n    publicKeyObject = this.publicKeyObject(publicKey);\n  } else if (originalFormat === 'der') {\n    if (typeof publicKey === 'buffer') {// do nothing\n    } else if (typeof publicKey === 'string') {\n      publicKey = new Buffer(publicKey, 'hex');\n    } else {\n      throw 'public key must be a buffer or a string';\n    }\n\n    publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n  } else if (originalFormat === 'pem') {\n    if (!typeof publicKey === 'string') {\n      throw 'public key must be a string';\n    }\n\n    publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n  } else {\n    throw 'invalid public key format';\n  }\n  /* Export the private key object to the desired format */\n\n\n  if (destinationFormat === 'raw') {\n    return publicKeyObject.pub.data.toString('hex');\n  } else if (destinationFormat === 'der') {\n    return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n  } else if (destinationFormat === 'pem') {\n    return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n  } else {\n    throw 'invalid destination format for public key';\n  }\n};\n\nmodule.exports = KeyEncoder;","map":null,"metadata":{},"sourceType":"script"}